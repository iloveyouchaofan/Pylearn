#classl.py
#coding:UTF-8
#Python 3.7.0?

'''
标注序号和尾部注记
	一个需要对应一条笔记。
	1、标注序号的格式：开头为#号，后面连接一个*号，然后再加上数字。如下：
	#*1
	2、标注序号在对应一个尾部注记。既在尾部对应一条笔记。

*后的内容是重点、几个概念的集中梳理。
？是疑问点。

'''

class abc1(object): #*1

	_a = None
	_b = None #*2

	def __init__(self, d, e): #*3
		self.d = d
		self.e = e
	'''
	1、
	__init__是一个特殊函数，用于给对象绑定属性。
		目前abc1中绑定了 d c 两个属性。
	注意：init 前后两个短下划线
	2、
	self可以理解为指向abc1，也就是指向自己。
		在构造类的时候，函数的第一个变量必须是self。
		不影响外调用。其他参数同函数。
	'''

#debug
f = abc1('str', 1)
print(f.d, f.e)

#尾部注记
'''
1、
1-1、类名和CLASS_Name()
	类名指向类本身。
		与函数不同的是，类本身在实例化之前，没有被分配内存地址（不了它具体的实现，用type()和“直接调用”实验时，返回值与函数的不同），
		而函名是指向包含函数功能内存地址的变量。
	CLASS_Nanme()，表示类的实例化。
		abc = CLASS_Nanme()，类的实例化。
1-2、括号和其中的object
	括号中必须含有一个值（类的名称），表示这个类继承哪个类。
		所有的类都是继承自object，因此在定义类的时候，即便是哪个类也不想继承，也要
		笑。就是说只能定义父亲这一层，上面的爷爷不能定义
	
	*类继承的概念：
	1、子类 Subclass、父类（基类 Base Class、超类）
		子类继承父类定义的属性和方法。（类属性、实力属性（模板）也继承？）
		同时，也可添加自己的属性、方法。
	2、子类覆盖
		子类中定义的属性、方法的名称与父类相同时，子类覆盖父类的属性和方法。
		名称空间？也是组成多态的特性之一。
	3、单向
		子类被区别对待。
			子类的类型于父类的一致，但是父类不能看成子类。
				因为子类可能会变！
		类似
			继承自同一个类的两个子类（不是同一子类的两个实例），它们之间“类似”
			疑问：它们的类型和父类一直吗？isinstance(x,x)
	4、继承树
		所有类都继承自object
		                    object
		         |                         |
		       class_A                  class_B
		         |                         |
		class_A_1   class_A_2     class_B_1   class_B_2
	5、多态？
		不太理解
	6、与静态语言的区分？
		完全不懂
2、类的属性
	类本身和它所有的子类都可以使用这个属性。
	?没有实例化的情况下可以访问吗？
3、实例的属性
	？没有实例化的情况下可以访问吗？
	？其他的、继承自相同父类的、可以访问吗？
		！很显然不能，也要测试一下。
	3-1、__init__
		是一个特殊的方法。
		是不是前后用__标记的都是特殊的变量名？解释成某种操作。例如__main__
	3-2、括号中的self和其他参数
		self必须设置、在首位，随后的参数设置于函数相同。
	3-3、参数的传递
		类在实例化的过程中，接受的参数传递给__init__中，位置对应，赋予给对应的属性。
		
		实际上是封装了一个函数过程：获得值，然后赋值，函数作为工具。
		？有格式检查吗？
		

阅读到：
2018-09-06
OOP高级编程
使用__slots__
@property完全不懂


'''
