#classl.py
#coding:UTF-8
#Python 3.7.0?

'''
标注序号和尾部注记
	一个需要对应一条笔记。
	1、标注序号的格式：开头为#号，后面连接一个*号，然后再加上数字。如下：
	#*1
	2、标注序号在对应一个尾部注记。既在尾部对应一条笔记。

*后的内容是重点、几个概念的集中梳理。
？是疑问点。

'''

class abc1(object): #*1

	_a = None
	_b = None #*2
	
	__inclassonly = 'hello'
	'''
	变量名称前加两个下划线 __ 表示该变量为私有变量。
	P.s 在类内，应成为属性。
	'''

	def __init__(self, d, e, f): #*3
		self.d = d
		self.e = e
		#实例的属性
		
		self.__inattonly = f
		#实例的私有属性
		#
		'''
		1、可以在实例化过程中赋值。
			__init__接受，注意参数位置和个数的对应。
		2、只声明不赋值。
		3、以上两种方法都可以通过@property 便捷访问
		'''
	
	#self是啥？
	'''
		self指向类或者实例本身，也就是指向自己，或者说表示自己。
	'''
	
	#类的两种状态：类和实例
	'''
		类：
			Python动态编译：
				type(类名字)的时候，返回的是<type 'type'>。
				实例化后：type(实例名),返回的是<type '类名字'atxxx>
				也就是说，类在实例化之前，没有在内存中编译成可执行的码。
				具体看解释：
			类可以实例成不同的实例。
				a = class_1()
				b = class_1()
				但，a 和 b 不同。
		实例：
		属性和方法的对应：
		__init__ 定义的属性为实例属性
			只有实例化话方可访问。
			只有实例自己可以访问：a不能访问b中的属性。
	'''
	
	#操私有属性的方法（1）
	#常规操作
	#实例、类私有属性均可。
	def setinonly(self, gg):
		self.__inclassonly = gg

	def getinonly(self):
		print(self.__inattonly)
		print(self.__inclassonly)

	#操作私有属性的方法（2）
	#			——— @property @XX.setter 优雅地操作
	@property
	#私有属性 __inattonly 无需事先声明
	#不再 __init__ 声明的私有属性，为类的私有属性
	#（名称作用空间）
	def inattonly(self):
		return self.__inattonly
	@inattonly.setter
	def inattonly(self, dd):
		self.__inattonly = dd

	'''
	*属性封装
	私有属性、操作的方法，巧合
	1、控制。
	'''
	

	'''
	1、
	__init__是一个特殊函数，用于给对象绑定属性。
		目前abc1中绑定了 d c 两个属性。
	注意：init 前后两个短下划线
	2、
	self可以理解为指向abc1，也就是指向自己。
		在构造类的时候，函数的第一个变量必须是self。
		不影响外调用。其他参数同函数。
	'''

def abc2():
	print('lalal')

#debug
#f = abc1('str', 1)
#f.getinonly()
#print(f.d, f.e)
#print(type(f))
f = abc1('str', 1, 88)
f.inattonly = 99
#print(abc1.inattonly)
print(f.inattonly) #


#尾部注记
'''
1、
1-1、类名和CLASS_Name()
	类名指向类本身。
		与函数不同的是，类本身在实例化之前，没有被分配内存地址（不了它具体的实现，用type()和“直接调用”实验时，返回值与函数的不同），
		而函名是指向包含函数功能内存地址的变量。
	CLASS_Nanme()，表示类的实例化。
		abc = CLASS_Nanme()，类的实例化。
1-2、括号和其中的object
	括号中必须含有一个值（类的名称），表示这个类继承哪个类。
		所有的类都是继承自object，因此在定义类的时候，即便是哪个类也不想继承，也要
		笑。就是说只能定义父亲这一层，上面的爷爷不能定义
	
	*类继承的概念：
	1、子类 Subclass、父类（基类 Base Class、超类）
		子类继承父类定义的属性和方法。（类属性、实力属性（模板）也继承？）
		同时，也可添加自己的属性、方法。
	2、子类覆盖
		子类中定义的属性、方法的名称与父类相同时，子类覆盖父类的属性和方法。
		名称空间？也是组成多态的特性之一。
	3、单向
		子类被区别对待。
			子类的类型于父类的一致，但是父类不能看成子类。
				因为子类可能会变！
		类似
			继承自同一个类的两个子类（不是同一子类的两个实例），它们之间“类似”
			疑问：它们的类型和父类一直吗？isinstance(x,x)
	4、继承树
		所有类都继承自object
		                    object
		         |                         |
		       class_A                  class_B
		         |                         |
		class_A_1   class_A_2     class_B_1   class_B_2
	5、多态？
		不太理解
	6、与静态语言的区分？
		完全不懂
	7、动态
		实例动态设置属性
		__slots__ 限制实例动态设置属性
		__slots__ = (tuple)
	8、self指向实例本身，class 模版的 一个组成部分

2、类的属性
	类本身和它所有的子类都可以使用这个属性。
	？！没有实例化的情况下可以访问吗？
		！可以。
3、实例的属性
	？！没有实例化的情况下可以访问吗？
		！不可以。Python会抛出错误，说class没有这个属性。
	？！其他的、继承自相同父类的、可以访问吗？
		！很显然不能，也要测试一下。
	
	*类的属性 和 实例的属性 合适能访问
	（2、3中的三个疑问）
		类是实例的模版，类被定义之后，类的属性也随之存在了，因此可以访问。
		实例的属性需要在，类被实例化之后，才被生成，因此需要在实例化后才能访问。

	设置实例属性需要通过 #*3 这样的语句实现。
	3-1、__init__
		是一个特殊的方法。
		？是不是前后用__标记的都是特殊的变量名？解释成某种操作。例如__main__
	3-2、括号中的self和其他参数
		self必须设置、且在首位。
		随后的参数设置于函数相同。？可以介绍可变参数吗？
	3-3、参数的传递
		类在实例化的过程中，接受的参数传递给__init__，内外参数，位置对应，赋予给对应的属性。
		参数传递规则和函数一样，因为本身就是一种东西！
		注意，实例化的过程中接受的参数，给了__init__函数即可。
		
		*设置实例属性，实际上是封装了一个函数过程：获得值，然后赋值，函数作为工具。
		也成为绑定属性。
		？！有格式检查吗？
			！推测没有格式检查。推测可以用类的装饰器实现。
4、属性的访问限制
	限制方法
	访问方法
	实例的属性
	类的属性
5、方法
	os.walk这样有返回值
	和调用函数一样。

高级对象编程
类的装饰器
	@property
	#读取值的函数
	@读取值的函数名.setter
	#获取值的函数
	成对出现，操作私有属性。

定制类
枚举类
元类



'''
